# This presentation was the closing keynote of the Heroku Waza conference in January, 2012.
# It has been slightly modified here for clarity and for use in the "present" format; the original
# used a precursor to that tool.

Concurrency is not Parallelism 
(Конкурентность – это не параллелизм)

Waza, 11 января 2012
 
Rob Pike
r@golang.org

* Запись выступления

Есть запись оригинального выступленя на конференции Waza от Heroku, которая прошла в январе 2012

.image waza/pike.png _ 300

Посмотреть можно по ссылке [[http://vimeo.com/49718712][http://vimeo.com/49718712]]

* Мы живем в эпоху параллелизма

Многоядерность.

Сети.

Облака для вычислений.

Наргузка от пользователей.

Технологии должны помогать нам во взаимодействии со всем этим.
И конкурентные вычисления делают это.

* Язык Go поддерживает конкурентные вычисления из коробки

Для этого Go предлагает:

- конкурентное исполнение (горутины)
- синхронизация и обмен сообщениями (каналы)
- одновременное управление конкурентными каналами (select)

*  Конкурентность - это куруто! Ура параллелизму!!

НЕТ! Ошибка.

Когда язык Go был представлен было много путаницы. Монгие не понимали разницу.

"У меня алогитм нахождения простых числел(решето Эратосфена) на 4 процессорах работает медленнее чем раньше!"

* Конкурентость

Программирование по принципу композиции независимо выполняющихся процессов.

(В общем понимании процессы – это не те процессы, что, например в Linux. Очень тяжело дать коррекное определение)

* Параллелизм

Программирование по принципу одновременного исполнения вычислений(возможно связанных). 


* Конкурентность vs. параллелизм

Конкурентость – это как взаимодействовать со множеством объектов одновременно.

Параллелизм – это как делать много дел одновременно.

Не одно и тоже, но связанно.

Конкурентность – это про структуру, тогда как параллелизм – это про исполнение.

Конкурентность позволяет выстроить решение проблемы, которое может быть(но не обязательно) распараллелено.

* Аналогия

Конкурентно: драйвера для мыши, клавиатуры, дисплея и жестких дисков.

Параллельно: произведение векторов, сетевое взаимодействие(например разговор по Skype: видео+голос одновременно).

* Конкурентность и коммуникация(обмен сообщениями)

Конкурентность – это способ структурировать программу путем разбиения ее на фрагменты, которые могут исполняться независимо.

Коммуникация(обмен сообщениями) необходима для координации независимо исполняющихся процессов.

По такой модели работает язык Go(как и язык Erlang и другие). Основой самой модели является CSP:

C. A. R. Hoare: Communicating Sequential Processes (CACM 1978)

* Суслики

Все что я рассказывал слишком абстрактно. Перейдем к конкретике.

* Опишем проблему

Отвезти стопку руководств по устаревшему языку программирования в мусоросжигательную печь.

.image waza/gophersimple1.jpg

Один сулик будет делать это очень долго.

* Нужно больше сусликов!

.image waza/gophersimple3.jpg

Не достаточно просто добавить новых сусликов, им нужны еще и тачки.

* Больше сусликов и больше тачек

.image waza/gophersimple2.jpg

Так дела пойдут быстрее, но образуются узкие места у стопки и у мусоросжигательной печи.
Также сусликов необходимо координировать.
Тут нам попмогут сообщения (Коммуникация между сусликами).

* Всего должно быть в два раза больше

Исключим узкие места – сделаем сусликов действительно независимыми.

.image waza/gophersimple4.jpg

Так мы сможем справляться с работой в два раза быстрее.

* Конкурентная композиция

.image waza/gophersimple4.jpg
Конкурентная композиция из двух сусликов.

* Конкурентная композиция

Такая конструкция не становится параллельной автоматически!

А что если в один момент времени работает только один суслик?
Тогда конструкция не перестанет быть конкурентной, но не параллельной.


Как правило, такие конструкции автоматически поддаются распараллеливанию.

Более того, конкурентная композиция позволяет выстраивать и другие конструкции.

* Другой подход

.image waza/gophercomplex0.jpg

Три суслика за работой. Они делают свое дело, но вероятно с задержками.
Каждый суслик – это независимо исполняемая процедура. 
Плюс координация(коммуникация/обмен сообщениями) между всеми тремя.

* Еще больше раздробим конкурентность

Добавим еще одну сусликовую процедуру, которая будет возвращать пустые тачки.
.image waza/gophercomplex1.jpg
Чтобы сгладить процесс теперь у нас четыре суслика за работой. Каждый выполняет одну простую задачу.

Если все организовать правильно(неправдоподобно, но не невозможно), то мы получим систему, которая работает в четыре раза быстрее, чем изначальная с одним сусликом. 

* Выводы

Мы повысили производительность нашей системы путем добавления конкурентных процедур к уже существующей конструкции.

Больше сусликов, которые выполняют больше работы – да, так работает лучше.

Это более глубокое понимание принципов утилизации ресурсов, чем просто параллелизм.


* Конкурентные процедуры

Четыре различные сусликовые процедуры:

- сложить книг в тачку
- отвезти тачку к мусоросжигательной печи
- выгрузить содержимое тачки в мусоросжигательную печь
- вернуть пустую тачку к стопке с книгами

Различные конкурентные подходы позволяют по рвзному распараллеливать работу.

* Больше параллелизма!

Теперь мы можем подойти к распараллеливанию с другой стороны. Конкурентные подходы делают эту задачу легкой. Восемь сусликов и все заняты.

.image waza/gophercomplex2.jpg

* Или возможно, у нас и вовсе не будет никакого параллелизма

Помните, даже если в один момент времени только один суслик будет активен(нет параллелизма), то наша конструкция не перестает быть правильной и конкурентной.

.image waza/gophercomplex2.jpg

* Другой подход

Here's another way to structure the problem as the concurrent composition of gopher procedures.
Вот вам другой возможный подход к решению проблемы путем организации сусликов в конкурентные процедуры.

Two gopher procedures, plus a staging pile.
Две сусликовые процедуры с промежуточной стопкой.

.image waza/gophercomplex3.jpg

* Распараллеливаем как обычно

Чтобы получить больую производительность запускаем больше конкурентных процедур.

.image waza/gophercomplex4.jpg

* Или еще один подход

Внедрим промежуточную стопку в конструкцию, где много сусликов:

.image waza/gophercomplex5.jpg

* Полная оптимизация

Используем одновременно все наши подходы. 

Все шестнадцать сусликов за тяжелым трудом!

.image waza/gophercomplex6.jpg

* Какие уроки можно извлечь

- Существует много подходов к разбиению процессов.
- Это и есть конкурентый подход к проектированию.
- Как только у нас появится разбиение процессов распараллеливание последует само собой.
- При этом все настолько просто, что при любом количестве ресурсов общий результат не страдает.

* Back to Computing

In our book transport problem, substitute:

- book pile => web content
- gopher => CPU
- cart => marshaling, rendering, or networking
- incinerator => proxy, browser, or other consumer

It becomes a concurrent design for a scalable web service.
Gophers serving web content.

* A little background about Go

Not the place for a tutorial, just quick highlights.

* Goroutines

A goroutine is a function running independently  in the same address space as other goroutines

.code waza/snippets /f.runs/

.code waza/snippets /f.starts.running/,/return/

Like launching a function with shell's `&` notation.

* Goroutines are not threads 

(They're a bit like threads, but they're much cheaper.)

Goroutines are multiplexed onto OS threads as required.

When a goroutine blocks, that thread blocks but no other goroutine blocks.

* Channels

Channels are typed values that allow goroutines to synchronize and exchange information.

.code waza/snippets /make.*chan/,/completedAt/

* Select

The `select` statement is like a `switch`, but the decision is based on ability to communicate rather than equal values.

.code waza/snippets /select/,/}/

* Go really supports concurrency

Really.

It's routine to create thousands of goroutines in one program.
(Once debugged a program after it had created 1.3 million.)

Stacks start small, but grow and shrink as required.

Goroutines aren't free, but they're very cheap.

* Closures are also part of the story

Make some concurrent calculations easier to express.

They are just local functions.
Here's a non-concurrent example:

.code waza/snippets /Compose/,/sin,/

* Some examples

Learn concurrent Go by osmosis.

* Launching daemons

Use a closure to wrap a background operation.

This copies items from the input channel to the output channel:

.code waza/snippets /copy.input/,/^}/

The `for` `range` operation runs until channel is drained.

* A simple load balancer (1)

A unit of work:

.code waza/load1 /type/,/^}/

* A simple load balancer (2)

A worker task

.code waza/load1 /worker/,/^}/

Must make sure other workers can run when one blocks.

* A simple load balancer (3)

The runner

.code waza/load1 /Run/,/^}/

Easy problem but also hard to solve concisely without concurrency.

* Concurrency enables parallelism

The load balancer is implicitly parallel and scalable.

`NumWorkers` could be huge.

The tools of concurrency make it almost trivial to build a safe, working, scalable, parallel design.

* Concurrency simplifies synchronization

No explicit synchronization needed.

The structure of the program is implicitly synchronized.

* That was too easy

Let's do a more realistic load balancer.

* Load balancer

.image waza/gopherchart.jpg

* Request definition

The requester sends Requests to the balancer

.code waza/load2 /^type.Request/,/^}/

Note the return channel inside the request.
Channels are first-class values.

* Requester function

An artificial but illustrative simulation of a requester, a load generator.

.code waza/load2 /^func.requester/,/^}/

* Worker definition

A channel of requests, plus some load tracking data.

.code waza/load2 /type.Worker/,/^}/

* Worker

Balancer sends request to most lightly loaded worker

.code waza/load2 /^func.*work.*done/,/^}/

The channel of requests (`w.requests`) delivers requests to each worker.  The balancer tracks the number of pending requests as a measure of load.
Each response goes directly to its requester.

Could run the loop body as a goroutine for parallelism.

* Balancer definition

The load balancer needs a pool of workers and a single channel to which requesters can report task completion.

.code waza/load2 /type.Pool/,/^}/

* Balancer function

Easy!

.code waza/load2 /func.*balance/,/^}/

Just need to implement dispatch and completed.

* A heap of channels

Make Pool an implementation of the `Heap` interface by providing a few methods such as:

.code waza/load2 /func.*Less/,/^}/

Now we balance by making the `Pool` a heap tracked by load.

* Dispatch

All the pieces are in place.

.code waza/load2 /Send.Request/,/^}/

* Completed

.code waza/load2 /Job.is.complete/,/^}/

* Lesson

A complex problem can be broken down into easy-to-understand components.

The pieces can be composed concurrently.

The result is easy to understand, efficient, scalable, and correct.

Maybe even parallel.

* One more example

We have a replicated database and want to minimize latency by asking them all and returning the first response to arrive.

* Query a replicated database

.code waza/snippets /func.Query/,/^}/
Concurrent tools and garbage collection make this an easy solution to a subtle problem.

(Teardown of late finishers is left as an exercise.)


* Conclusion


Concurrency is powerful.

Concurrency is not parallelism.

Concurrency enables parallelism.

Concurrency makes parallelism (and scaling and everything else) easy.

* For more information

Go: golang.org

Some history: swtch.com/~rsc/thread/

A previous talk (video): tinyurl.com/newsqueak1

Parellelism is not concurrency (Harper): tinyurl.com/pincharper

A concurrent window system (Pike): tinyurl.com/pikecws

Concurrent power series (McIlroy): tinyurl.com/powser

And finally, parallel but not concurrent:
research.google.com/archive/sawzall.html
